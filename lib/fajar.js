const fetch = require('node-fetch')const fs = require('fs')const FormData = require('form-data')const { fromBuffer } = require('file-type')const cheerio = require('cheerio')const axios = require('axios')const { default: Axios } = require('axios')const { JSDOM } = require('jsdom')const os = require('os')const path = require('path')const util = require('util')const moment = require('moment-timezone')const time = moment().format('DD/MM HH:mm:ss')const { color, bgcolor } = require('./color')const { Readable, Writable } = require('stream') function uploadimg (filename, name) {    var image = fs.createReadStream(filename)    var form = new FormData()    form.append('image', image, name)         const upload = fetch('https://storage.naufalhoster.xyz', {        method: 'POST',        body: form    }).then((response) => response.json())        .then((result) => {            return result        })        .catch(e => {            return e        })    return upload}function upload (media)  {    return new Promise(async (resolve, reject) => {    try {        let { ext } = await fromBuffer(media)        console.log('Uploading image to server telegra.ph')        let form = new FormData()        form.append('file', media, 'tmp.' + ext)        await fetch('https://telegra.ph/upload', {            method: 'POST',            body: form        })        .then(res => res.json())        .then(res => {            if (res.error) return reject(res.error)            resolve('https://telegra.ph' + res[0].src)        })        .catch(err => reject(err))    } catch (e) {        return console.log(e)    }})}const lirikLagu = async (query) => {const res = await axios.get(`https://www.musixmatch.com/search/${query}`)const sup = cheerio.load(res.data)const hasil = []const b = sup('#site').find('div > div > div > div > ul > li:nth-child(1) > div > div > div')let link = `https://www.musixmatch.com` + sup(b).find('h2 > a').attr('href')const des = await axios.get(link)const soup = cheerio.load(des.data)const result = soup('#site').find('.mxm-lyrics__content > .lyrics__content__ok').text()hasil.push({ result})return hasil}const wikiSearch = async (query) => {const res = await axios.get(`https://id.m.wikipedia.org/w/index.php?search=${query}`)const $ = cheerio.load(res.data)const hasil = []let wiki = $('#mf-section-0').find('p').text()let thumb = $('#mf-section-0').find('div > div > a > img').attr('src')thumb = thumb ? thumb : '//pngimg.com/uploads/wikipedia/wikipedia_PNG35.png'thumb = 'https:' + thumblet judul = $('h1#section_0').text()hasil.push({ wiki, thumb, judul })return hasil}function herolist(){            return new Promise((resolve, reject) => {                  Axios.get('https://mobile-legends.fandom.com/wiki/Mobile_Legends:_Bang_Bang_Wiki')                  .then(({ data }) => {                       const $ = cheerio.load(data)                       let data_hero = []                       let url = []                       $('div > div > span > span > a').get().map((result) => {                            const name = decodeURIComponent($(result).attr('href').replace('/wiki/',''))                            const urln = 'https://mobile-legends.fandom.com' + $(result).attr('href')                            data_hero.push(name)                            url.push(urln)                       })                       resolve({ status: 200, hero: data_hero })                  }).catch((e) => reject({ status: 404, message: e.message }))             })        }        function herodetails(name) {             return new Promise((resolve, reject) => {                  var splitStr = name.toLowerCase().split(' ');                  for (var i = 0; i < splitStr.length; i++) {                       splitStr[i] = splitStr[i].charAt(0).toUpperCase() + splitStr[i].substring(1);                       }                  const que = splitStr.join(' ')                  Axios.get('https://mobile-legends.fandom.com/wiki/' + que)                  .then(({ data }) => {                       const $ = cheerio.load(data)                       let mw = []                       let attrib = []                       let skill = []                       const name = $('#mw-content-text > div > div > div > div > div > div > table > tbody > tr > td > table > tbody > tr > td > font > b').text()                        $('.mw-headline').get().map((res) => {                            const mwna = $(res).text()                            mw.push(mwna)                       })                       $('#mw-content-text > div > div > div > div > div > div > table > tbody > tr > td').get().map((rest) => {                            const haz = $(rest).text().replace(/\n/g,'')                            attrib.push(haz)                       })                       $('#mw-content-text > div > div > div > div > div > div > table > tbody > tr > td > div.progressbar-small.progressbar > div').get().map((rest) => {                            skill.push($(rest).attr('style').replace('width:',''))                       })                       Axios.get('https://mobile-legends.fandom.com/wiki/' + que + '/Story')                       .then(({ data }) => {                            const $ = cheerio.load(data)                            let pre = []                            $('#mw-content-text > div > p').get().map((rest) => {                                 pre.push($(rest).text())                            })                            const story = pre.slice(3).join('\n')                            const items = []                            const character = []                            $('#mw-content-text > div > aside > section > div').get().map((rest) => {                                 character.push($(rest).text().replace(/\n\t\n\t\t/g, '').replace(/\n\t\n\t/g,'').replace(/\n/g,''))                            })                            $('#mw-content-text > div > aside > div').get().map((rest) => {                                 items.push($(rest).text().replace(/\n\t\n\t\t/g, '').replace(/\n\t\n\t/g,'').replace(/\n/g,''))                            })                            const img = $('#mw-content-text > div > aside > figure > a').attr('href')                            const chara = character.slice(0,2)                            const result = {                                  status: 200,                                 hero_name: name + ` ( ${mw[0].replace('CV:',' CV:')} )`,                                 entrance_quotes: attrib[2].replace('Entrance Quotes','').replace('\n',''),                                 hero_feature: attrib[attrib.length - 1].replace('Hero Feature',''),                                 image: img,                                 items: items,                                 character: {                                      chara                                 },                                 attributes: {                                      movement_speed: attrib[12].replace('● Movement Speed',''),                                      physical_attack: attrib[13].replace('● Physical Attack',''),                                      magic_power: attrib[14].replace('● Magic Power',''),                                      attack_speed: attrib[15].replace('● Attack Speed',''),                                      physical_defense: attrib[16].replace('● Physical Defense',''),                                      magic_defense: attrib[17].replace('● Magic Defense',''),                                      basic_atk_crit_rate: attrib[18].replace('● Basic ATK Crit Rate',''),                                      hp: attrib[19].replace('● HP',''),                                      mana: attrib[20].replace('● Mana',''),                                      ability_crit_rate: attrib[21].replace('● Ability Crit Rate',''),                                      hp_regen: attrib[22].replace('● HP Regen',''),                                      mana_regen: attrib[23].replace('● Mana Regen','')                                 },                                 price: {                                      battle_point: mw[1].split('|')[0].replace(/ /g,''),                                      diamond: mw[1].split('|')[1].replace(/ /g,''),                                      hero_fragment: mw[1].split('|')[2] ? mw[1].split('|')[2].replace(/ /g,'') : 'none'                                 },                                 role: mw[2],                                 skill: {                                      durability: skill[0],                                      offense: skill[1],                                      skill_effects: skill[2],                                      difficulty: skill[3]                                 },                                 speciality: mw[3],                                 laning_recommendation: mw[4],                                 release_date: mw[5],                                 background_story: story                            }                            resolve(result)                       }).catch((e) => reject({ status: 404, message: e.message }))                  }).catch((e) => reject({ status: 404, message: e.message }))             })        }const mediafireDl = async (url) => {const res = await axios.get(url) const $ = cheerio.load(res.data)const hasil = []const link = $('a#downloadButton').attr('href')const size = $('a#downloadButton').text().replace('Download', '').replace('(', '').replace(')', '').replace('\n', '').replace('\n', '').replace('                         ', '')const seplit = link.split('/')const nama = seplit[5]mime = nama.split('.')mime = mime[1]hasil.push({ nama, mime, size, link })return hasil}async function pinterest(querry) {	let HASIL = []	await axios.request(`https://id.pinterest.com/search/pins/?rs=typed&q=` + querry, {			method: "GET",			url: "https://id.pinterest.com/search/pins/?rs=typed&q="+ querry,			headers: {				"sec-ch-ua": "\" Not A;Brand\";v=\"99\", \"Chromium\";v=\"90\", \"Google Chrome\";v=\"90\"",				"sec-ch-ua-mobile": "?0",				"upgrade-insecure-requests": "1",				"cookie": "csrftoken=ebe0be3a93cea6072be18633add953a2; _b=\"AVezvd6F4UtE24FUsA6INxipyZZDoSpyCc5vaJK4QDYXmExosVEc4h6WkiKhlVtQ430=\"; cm_sub=denied; fba=True; _ga=GA1.2.862909259.1620474446; g_state={\"i_l\":0}; _auth=1; _pinterest_sess=TWc9PSZ0VEZqZmdDSlJYaGU5REIvNklIcVlnMjE5b0ZraTE5REJVQ0JiMUwxTkZZaGFoVk1sRDVhOFlwQzhkQnQ0YkMwRlNyV0lIWUFlK0ZVTkVxYUhKNmlvZ0R1UXlQYTBRRVVhMU1yYkpmcXpHK3UyNjNhckRqUFFOYVJVa3RnVmJtVzd2MmRGaHFMZUpLNVhtaHptTDhWSnBSdXhZY0FhRnRTN3J1S0V4cGtsVTBxeE54NkF2blVNSFV3R0NTQTR1bVVNRURGVGdnYlN5UjdBbk9YcHVGbGI3a1kwd1dEZDgrZVM1SDc3V0pJMm00OWxKUDVNQjBLVlFocTB4Mjg1M1RnbGxBaFAxbS9MTnVzei91cEQvcjBtakp6N0ZnU2t1Y3NxWW1DRDV1Q3h0ankvQ3FEWGh3MXczcXBHNXJpYVNCMHB6dUoxMGF6ZzVxN2VqQVBoSElSd0tiQk41ZVRPQXlOaGNpNzVQMWJSeVZJbCtYYVMxQ1ZRUFUwalU3eGVzMGRySlNzdWo1NG5uaXNFM3ZpT0o0TkZHR1daUXlwaXFQclMwa04raW9xVnVaTTRSVGEzTE03TVlZcmZYVDd5UmVPd2lZaGw4aE9VMHJBd0tidEsrcHdPWk96RlFMekVLTzY3VU1PL0tIYUdwUE1IWVdJNnJXalBkU09Sb3dEaHlQVVR1T1RqNW5Sc2FRdmVkZmhkMk9HNHBCL0ZpZ3NMdmZvVW9ReVltTFBCTlNLWHpray9LNWJ2UTNvTlBzVm9aZjRvYWRvRFhla0dBNzdveWJVYXZmVFp2cnFFNU5DYUVwSHhxeDlIajNIVTlHaEVYdGptWm5mSGVSRmtIMmQwVVVVZlVCVEh6UHB3TnBtdWV0b2l6L3VTc3pXMXFGN3lHS3ZJM3BwL0NrWVJDMm1HY2tROGxuQVFRNS9OUW45R3dtSk8zeFJidVFSTG1qTG5PelAvKzd3T3lrN1NoKzBHVGNTY1pGSEY0bW8xcGVmc3NtclBhTWE2QUMxOXNpQWUwRmo4UHl0ZGpwUzhUQXVhbjYwT0ZJeHhHai8yOWFUVTA1Wkx2czN4VSttLzMvbkFVQ2svWnZvNC9xZ3E4VkhYSFZ5elo4TzhtU0o5c3ZDcEJyYjE3QVI1WHlmTTFhWThvWHQ1T0tSTWRsWnI3a1lpU245dEVLd1lZSXRremtkTUZmcVA2YUg0c1UrSk1JOWJVRzZpcWd3T0NVaFZkdUh3UUdURi9sbDBqT2pBZVV2ZnlTQzc5ZnBMYkFMQ1ZsWjdIYWcmaDc1Uk5kK2I4MjFMUXBaVUthci9rVHpCUWRvPQ==; _pinterest_cm=\"TWc9PSYxZnpkMS9XN29Rd2R0TnpBN0RzVktja1J4NUtINUJqRzNGODFXS0xES1pndWlNVm52a0d3V0JocmVIS3p5eDdnNXNZa0hGelNQNDBSTFRId3ZhTFFIQjRGOW1lNlJZMzFiVlg1MHhSOFpmMGhRZUoySUpJZDIyWlVYMjRXNHRaL1lodFl4eW1jWjNyTklpbytYbHZyd29nRm5DY0pQOGgyUWpDdk9zQ1craXR5VEZoNHV4ZzRnOXV4SUFFSStYZCsmT08zMFI1bktXa3pwSDFtK3NNRWpxWWNpQzNzPQ==\"; _routing_id=\"595f24cd-7f4c-4495-aa67-37212d099cd8\"; sessionFunnelEventLogged=1"			}		}).then(res => {			const $ = cheerio.load(res.data)			let hasil = []			$('body > div > div > div > div > div > div > div > div > div > div > div').each(function (a, b) {				$(b).find('div').each(function (c, d) {					let Link = $(d).find('div > div > div > div > a').find('img').attr('src')					hasil.push(Link)				})			})			let Data = []			hasil.map(V => {				if (V === undefined) return 				Data.push(V.replace('236x', 'originals'))			})			let FilterArray = new Set(Data)			let unique = [...FilterArray]			const result = {				status: res.status,				creator: "@Denz",				result: unique			}			HASIL.push(result)		})		return HASIL[0]}const ytIdRegex = /(?:http(?:s|):\/\/|)(?:(?:www\.|)youtube(?:\-nocookie|)\.com\/(?:watch\?.*(?:|\&)v=|embed\/|v\/)|youtu\.be\/)([-_0-9A-Za-z]{11})/function INFOLOG(info) {    return console.log('\x1b[1;34m~\x1b[1;37m>>', '[\x1b[1;33mINF\x1b[1;37m]', time, color(info))}function post(url, formdata) {    INFOLOG(Object.keys(formdata).map(key => `${key}=${encodeURIComponent(formdata[key])}`).join('&'))    return fetch(url, {        method: 'POST',        headers: {            accept: "*/*",            'accept-language': "en-US,en;q=0.9",            'content-type': "application/x-www-form-urlencoded; charset=UTF-8"        },        body: Object.keys(formdata).map(key => `${key}=${encodeURIComponent(formdata[key])}`).join('&')    })}function ytv(url) {    return new Promise((resolve, reject) => {        if (ytIdRegex.test(url)) {            let ytId = ytIdRegex.exec(url)            url = 'https://youtu.be/' + ytId[1]            post('https://www.y2mate.com/mates/en60/analyze/ajax', {                url,                q_auto: 0,                ajax: 1            })                .then(res => res.json())                .then(res => {                    INFOLOG('Scraping...')                    document = (new JSDOM(res.result)).window.document                    yaha = document.querySelectorAll('td')                    filesize = yaha[yaha.length - 23].innerHTML                    id = /var k__id = "(.*?)"/.exec(document.body.innerHTML) || ['', '']                    thumb = document.querySelector('img').src                    title = document.querySelector('b').innerHTML                    post('https://www.y2mate.com/mates/en60/convert', {                        type: 'youtube',                        _id: id[1],                        v_id: ytId[1],                        ajax: '1',                        token: '',                        ftype: 'mp4',                        fquality: 360                    })                        .then(res => res.json())                        .then(res => {                            let KB = parseFloat(filesize) * (1000 * /MB$/.test(filesize))                            resolve({                                dl_link: /<a.+?href="(.+?)"/.exec(res.result)[1],                                thumb,                                title,                                filesizeF: filesize,                                filesize: KB                            })                        }).catch(reject)                }).catch(reject)        } else reject('URL INVALID')    })}function yta(url) {    return new Promise((resolve, reject) => {        if (ytIdRegex.test(url)) {            let ytId = ytIdRegex.exec(url)            url = 'https://youtu.be/' + ytId[1]            post('https://www.y2mate.com/mates/en60/analyze/ajax', {                url,                q_auto: 0,                ajax: 1            })                .then(res => res.json())                .then(res => {                    let document = (new JSDOM(res.result)).window.document                    let type = document.querySelectorAll('td')                    let filesize = type[type.length - 10].innerHTML                    let id = /var k__id = "(.*?)"/.exec(document.body.innerHTML) || ['', '']                    let thumb = document.querySelector('img').src                    let title = document.querySelector('b').innerHTML                    post('https://www.y2mate.com/mates/en60/convert', {                        type: 'youtube',                        _id: id[1],                        v_id: ytId[1],                        ajax: '1',                        token: '',                        ftype: 'mp3',                        fquality: 128                    })                        .then(res => res.json())                        .then(res => {                            let KB = parseFloat(filesize) * (1000 * /MB$/.test(filesize))                            resolve({                                dl_link: /<a.+?href="(.+?)"/.exec(res.result)[1],                                thumb,                                title,                                filesizeF: filesize,                                filesize: KB                            })                        }).catch(reject)                }).catch(reject)        } else reject('URL INVALID')    })}async function ytsr(query) {    let link = /youtube\.com\/results\?search_query=/.test(query) ? query : ('https://youtube.com/results?search_query=' + encodeURIComponent(query))    let res = await fetch(link)    let html = await res.text()    let data = new Function('return ' + /var ytInitialData = (.+)/.exec(html)[1])()    let lists = data.contents.twoColumnSearchResultsRenderer.primaryContents.sectionListRenderer.contents[0].itemSectionRenderer.contents    let formatList = {        query,        link,        items: []    }    for (let list of lists) {        let type = {            videoRenderer: 'video',            shelfRenderer: 'playlist',            radioRenderer: 'live',            channelRenderer: 'channel',            showingResultsForRenderer: 'typo',            horizontalCardListRenderer: 'suggestionCard',        }[Object.keys(list)[0]] || ''        let content = list[Object.keys(list)[0]] || {}        if (content) {            switch (type) {                case 'typo':                    formatList.correctQuery = content.correctedQuery.runs[0].text                    break                case 'video':                    formatList.items.push({                        type,                        title: content.title.runs[0].text.replace('â€’', '‒'),                        views: content.viewCountText.simpleText,                        description: content.descriptionSnippet ? content.descriptionSnippet.runs[0].text.replace('Â ...', ' ...') : '',                        duration: content.lengthText ? [content.lengthText.simpleText, content.lengthText.accessibility.accessibilityData.label] : ['', ''],                        thumbnail: content.thumbnail.thumbnails,                        link: 'https://youtu.be/' + content.videoId,                        videoId: content.videoId,                        author: {                            name: content.ownerText.runs[0].text,                            link: content.ownerText.runs[0].navigationEndpoint.commandMetadata.webCommandMetadata.url,                            thumbnail: content.channelThumbnailWithLinkRenderer ? content.channelThumbnailWithLinkRenderer.thumbnail.thumbnails : [],                            verified: content.ownerBadges && /BADGE_STYLE_TYPE_VERIFIED/.test(content.ownerBadges[0].metadataBadgeRenderer.style) ? /BADGE_STYLE_TYPE_VERIFIED_ARTIST/.test(content.ownerBadges[0].metadataBadgeRenderer.style) ? 'artist' : true : false                        }                    })                    break                case 'channel':                    formatList.items.push({                        type,                        title: content.title ? content.title.simpleText.replace('â€’', '‒') : '',                        description: content.descriptionSnippet ? content.descriptionSnippet.runs[0].text.replace('Â ...', ' ...') : '',                        videoCount: content.videoCountText ? content.videoCountText.runs[0].text : '',                        thumbnail: content.thumbnail.thumbnails,                        subscriberCount: content.subscriberCountText ? content.subscriberCountText.simpleText.replace('Â ', ' ') : '',                        link: 'https://youtube.com' + content.navigationEndpoint.commandMetadata.webCommandMetadata.url,                        verified: content.ownerBadges && /BADGE_STYLE_TYPE_VERIFIED/.test(content.ownerBadges[0].metadataBadgeRenderer.style) ? /BADGE_STYLE_TYPE_VERIFIED_ARTIST/.test(content.ownerBadges[0].metadataBadgeRenderer.style) ? 'artist' : true : false                    })                    break                case 'playlist':                    formatList.items.push({                        type,                        title: content.title.simpleText.replace('â€’', '‒'),                    })                    break            }        }    }    return formatList}function baseURI(buffer = Buffer.from([]), metatype = 'text/plain') {    return `data:${metatype};base64,${buffer.toString('base64')}`}/** * Writable Stream Callback * @callback WritableStreamCallback * @param {WritableStream} stream  *//** * Convert Writable Stream to Buffer * @param {WritableStreamCallback} cb Callback with stream * @returns {Promise<Buffer>} */function stream2Buffer(cb = noop) {    return new Promise(resolve => {        let write = new Writable()        write.data = []        write.write = function (chunk) {            this.data.push(chunk)        }        write.on('finish', function () {            resolve(Buffer.concat(this.data))        })        cb(write)    })}/** * Convert Buffer to Readable Stream * @param {Buffer} buffer * @returns {ReadableStream} */function buffer2Stream(buffer) {    return new Readable({        read() {            this.push(buffer)            this.push(null)        }    })}/** * No Operation *  */function noop() { }module.exports.baseURI = baseURImodule.exports.ytsr = ytsrmodule.exports.yta = ytamodule.exports.ytv = ytvmodule.exports.buffer2Stream = buffer2Streammodule.exports.stream2Buffer = stream2Buffermodule.exports.noop = noopmodule.exports.pinterest = pinterestmodule.exports = { mediafireDl }exports.herodetails = herodetailsexports.herolist = herolistmodule.exports = { wikiSearch}module.exports = { lirikLagu }module.exports.upload = uploadmodule.exports.uploadimg = uploadimg